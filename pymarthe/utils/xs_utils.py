
# -- Import basic python modules
import pandas as pd
import numpy as np
from operator import itemgetter

# -- Import visualisation module
import matplotlib.pyplot as plt
from matplotlib.collections import PathCollection
from matplotlib.path import Path
from matplotlib.transforms import blended_transform_factory

# -- Import pymarthe objects
from pymarthe.utils import marthe_utils
from pymarthe.utils.shp_utils import read_shapefile
from pymarthe.mfield import MartheField

# -- Import additionnal geometry module
try:
	from shapely.geometry import Polygon, Point, LineString, MultiPoint
	from shapely.ops import unary_union
	from shapely.affinity import translate
except:
    ImportError("Could not import python `shapely` package!")


# -- Set default parameters
DEFAULT_PATH_KWARGS = {
	'alpha': .9,
	'fc': 'lightgrey',
	'lw': .4,
	'ls': '-',
	'ec': 'black'
}

DEFAULT_LAYERS_COLORBAR_KWARGS = {
	'ticks': [],
	'orientation': "horizontal",
    'location': 'top',
    'fraction': 0.07,
    'shrink': .9
}


DEFAULT_ARRAY_COLORBAR_KWARGS = {
	'orientation': "horizontal",
    'location': 'top',
    'fraction': 0.12,
    'shrink': .75
}

DEFAULT_CROSS_SECTION_LINE_KWARGS = {
	'lw': 1.6,
	'color': 'red',
	'ls': '-',
	'zorder': 50
}



class CrossSection():
	""" MartheModel Cross Section Management class """

	def __init__(self, mm, cross_section_line):
		""" 


        Parameters:
        ----------
        mm (MartheModel): existing MartheModel to consider.
        cross_section_line (list/dict/str): cross line definition object.
        									It can be:
        										- `str` : shapefile object
        										- `list`: list of points forming a line
        										- `dict`: 1-key dictionary.
        										          Accepted key words are:
        										          	- `i` or `row`: row number to draw the cross line.
        										          	                (not available for nested model)
        										          	- `j` or `column`: column number to draw the cross line.
        										          	                   (not available for nested model)
        										          	- `x`: x-coordinate to draw the cross line.
        										          	- `y`: y_coordinate to draw the cross line.

        Examples:
        --------
        mm = MartheModel('model.rma')
        xs = CrossSection(mm, cross_section_line='crossline.shp')
        xs = CrossSection(mm, cross_section_line=[(235.4, 356.2), (476.1, 789.3)])
        xs = CrossSection(mm, cross_section_line={'row': 25}) # or {'i': 25}
        xs = CrossSection(mm, cross_section_line={'column': 25}) # or {'j': 34}
        xs = CrossSection(mm, cross_section_line={'x': 324.7})
        xs = CrossSection(mm, cross_section_line={'y': 546.2})
		"""
		self.mm = mm
		self.modelgrid = self.get_modelgrid()
		self.set_cross_section_line(cross_section_line)


	@property
	def valid_xsnodes(self) -> np.ndarray:
		""" Valid cross section node numbers (icells) """
		_valid_xsnodes = (
			self.modelgrid
			.query(
				' & '.join(['active == 1.',
							'top.notnull()',
							'bottom.notnull()',
							'node in @self.xsnodes'])
				)
			.index
			.values
		)
		return _valid_xsnodes


	@property
	def plottable_xsnodes(self):
		""" Valid cross section node numbers for plotting purpose (icells) """
		return self.xs_df.node.values


	@property
	def offset(self):
		""" Computed offset applied to cross section line to avoid intersecting cell's border """
		return self.modelgrid[['dx','dy']].min().div(10).min()

	
	def validate_ax(self, ax):
		""" 
		Check if given axe was generated by either
		`.plot_xs()` or `plot_xs_field()` internal method

        Parameters:
        ----------
        ax (Axesubplot) : matplotlib subplot.

        Examples:
        --------
        ax = xs.plot_xs()
        xs.validate_ax(ax)

		"""
		msg = 'Invalid `ax`, must be a `AxesSubplot` produced ' \
		 	  'by the internal `.plot_xs()` method.'
		assert ax.get_gid().startswith('xs'), msg



	def get_modelgrid(self):
		"""
		Return main model modelgrid with z-dimension.

		Returns:
		-------
		modelgrid (DataFrame) : MartheModel modelgrid.

        Examples:
        --------
        mg = xs.get_modelgrid() # or xs.modelgrid

		"""
		# -- Load modelgrid with vertical information
		if self.mm.modelgrid is None:
			self.mm.build_modelgrid(add_z=True)
		if 'dz' not in self.mm.modelgrid.columns:
			self.mm.build_modelgrid(add_z=True)
		# -- Return fully modelgrid DataFrame
		return self.mm.modelgrid.copy(deep=True)



	def set_cross_section_line(self, xsline):
		"""
		Set cross section line as LineString in attribut
		
        Parameters:
        ----------
        xsline (list/dict/str): cross line definition object.
								It can be:
									- `str` : shapefile object
									- `list`: list of points forming a line
									- `dict`: 1-key dictionary.
									          Accepted key words are:
									          	- `i` or `row`: row number to draw the cross line.
									          	                (not available for nested model)
									          	- `j` or `column`: column number to draw the cross line.
									          	                   (not available for nested model)
									          	- `x`: x-coordinate to draw the cross line.
									          	- `y`: y_coordinate to draw the cross line.
		Examples:
		---------
		mm = MartheModel('model.rma')
        xs = CrossSection(mm, cross_section_line='crossline.shp')
        xs.set_cross_section_line([(235.4, 356.2), (476.1, 789.3)])
        xs.set_cross_section_line({'row': 25})
		"""
		# -- Manage xsline geometry input
		if isinstance(xsline, LineString):
			self.xsline = xsline

		# -- Manage xsline shapefile input
		if isinstance(xsline, str):
			self.xsline = LineString(read_shapefile(xsline).loc[0, 'coords'])

		# -- Manage iterable input 
		if marthe_utils.isiterable(xsline):

			if isinstance(xsline, dict):

				# -- Assert that the dict as exactly 1 valid key
				valid_keys = ['row', 'column', 'i', 'j', 'x', 'y']
				msg = "Input dictionary must have exactly 1 of the following keys:\n"
				msg += '\n'.join([ f'\t- {s}' for s in valid_keys])
				assert (0 < len(xsline) <= 1) & (all(k in valid_keys for k in xsline.keys())), msg

				# -- Extract keys and value and model extent
				(k, v), = xsline.items()
				xmin, ymin, xmax, ymax = self.mm.get_extent()

				# -- Manage understandable 'row', 'i' input
				if k.lower() in ['row', 'i']:
					# -- Discard nested model
					msg = 'Building cross section by row not available for nested model. '
					msg += "Consider using the 'y' key instead. Example: `xsline={'y': 334.3}`"
					assert len(self.mm.rlevels) <= 1, msg

					# -- Check row number
					rows = self.modelgrid['i'].unique()
					msg = f'Row number (0-based) must be {min(rows)} <= row <= {max(rows)}.'
					assert v in rows, msg

					# -- Build 2 representative points of the required row
					y = (self.modelgrid
						 .query("i == @v & layer == 0")[['ycc', 'dy']]
						 .iloc[0]
						 .sum())
					pts = [[xmin, y], [xmax, y]]

				# -- Manage understandable 'column', 'j' input
				if k.lower() in ['column', 'j']:
					# -- Discard nested model
					msg = 'Building cross section by column not available for nested model. '
					msg += "Consider using the 'x' key instead. Example: `xsline={'x': 451.1}`"
					assert len(self.mm.rlevels) <= 1, msg

					# -- Check column number
					cols = self.modelgrid['j'].unique()
					msg = f'Row number (0-based) must be {min(cols)} <= row <= {max(cols)}.'
					assert v in cols, msg

					# -- Extract 2 representative points of the required column
					x = (self.modelgrid
						.query("j == @v & layer == 0")[['xcc', 'dx']]
						.iloc[0]
						.sum())
					pts = [[x, ymin], [x, ymax]]

				# -- Manage x-coordinate as input
				if k.lower() == 'x':
					# -- Assert x is in extent
					msg = f'x-coodinate must be in model extent: {xmin} <= x <= {xmax}.'
					assert xmin <= v <= xmax, msg

					# -- Build 2 representative points of the required x-coordinate
					pts = [[v, ymin], [v, ymax]]

				# -- Manage x-coordinate as input
				if k.lower() == 'y':
					# -- Assert x is in extent
					msg = f'y-coodinate must be in model extent: {ymin} <= y <= {ymax}.'
					assert ymin <= v <= ymax, msg

					# -- Build 2 representative points of the required x-coordinate
					pts = [[xmin, v], [xmax, v]]

				# -- Build cross line from extracted points
				self.xsline = LineString(pts)

			else:
				# -- Build cross line from input point coordinates
				self.xsline = LineString(xsline)

		# -- Collect intersected nodes between line and model cells
		xsnodes = (
				self.modelgrid
				.loc[
					np.tile(
						(self.modelgrid
							.query('layer == 0')['vertices']
							.map(Polygon)
							.map(self.xsline.intersects)),
						reps=self.mm.nlay
					)
				]
				.index
				.values
			)
		# -- Store cross section nodes in attribut & build cross section dataframe
		self.xsnodes = xsnodes
		self.xs_df = self.get_xs_df()



	def get_xs_df(self):
		"""
		Extract all usefull informations about crossed cells as dataframe.

        Returns:
        ----------
        xs_df (DataFrame): cross section dataframe.
        				   Additional columns from modelgrid are:
        				   	- 'x_curv0': curvilinear abscissa of first intersection
        				   				 point between cell border and cross line
        				    - 'x_curv1': curvilinear abscissa of second intersection
        				   				 point between cell border and cross line
        				   	- 'zvertices': cell vertices on the z-dimension

        Examples:
        --------
        xs_df = xs.get_xs_df()

		"""
		xs_df = (
			# -- Start from base modelgrid
			self.modelgrid
			# -- Extract vertices of on valid nodes
			.loc[self.valid_xsnodes, 'vertices']
			# -- Convert crossed cells to shapely polygon
			.map(Polygon)
			# -- Perform intersection between valid cells and cross line
			.apply(
				lambda p: (
					LineString(p.exterior.coords)
					.intersection(translate(xs.xsline, xoff=self.offset, yoff=self.offset))
					)
				)
			# -- Manage different intersection objects (Point, MultiPoint)
			.apply(
				lambda g: [Point(p.x, p.y) for p in g.geoms]
				if isinstance(g, MultiPoint)
				else np.NaN
				)
			.dropna()
			# -- Expand series of list of points to flat points series
			.explode()
			# -- Compute curvilinear abscissa of each points
			.apply(lambda p: self.xsline.project(p))
			# -- Convert to Dataframe renaming columns
			.reset_index()
			.set_axis(['node', 'x_curv'], axis=1)
			# -- Get first/last curvilinear abscissa for each crossed node into a list
			.groupby('node', group_keys=True)['x_curv']
			.apply(list)
			# -- From list to separate columns
			.transform({'x_curv0': itemgetter(0), 'x_curv1': itemgetter(1)})
			.reset_index()
			# -- Merge to main modelgrid to retrive all grid infos
			.merge(self.modelgrid, on='node')
			# -- Add vertices of each crossed cells for z-dimension
			.assign(zvertices=lambda d:
				d.apply(lambda row: [[row['x_curv0'], row['top']],
									 					 [row['x_curv0'], row['bottom']],
									           [row['x_curv1'], row['bottom']],
									           [row['x_curv1'], row['top']],
									           [row['x_curv0'], row['top']]], axis=1))	
		)
		# -- Return the cross section DataFrame
		return xs_df



	def plot(self, ax=None, **kwargs):
		"""
		Visualize cross section line in xy-dimension.

		Parameters:
		-----------
		ax (Axesubplot, optional) : custom matplotlib subplot.
		***kwargs : matplotlib.axes.Axes.plot arguments.

        Returns:
        ----------
        ax (Axesubplot) : output matplotlib subplot.

        Examples:
        --------
        ax = xs.plot(lw=1.5, ls=':', color='green')
        plt.show()
		"""
		# -- Prepare basic axe if not provided
		if ax is None:
			fig, ax = plt.subplots(figsize=(9, 8))

		# -- Manage cross section line kwargs
		if len(kwargs) > 0:
			kwargs['zorder'] = 50
		else:
			kwargs = DEFAULT_CROSS_SECTION_LINE_KWARGS

		# -- Perform unary union of all active outcroping polygons
		uu = unary_union( 
				(
				self.modelgrid
				# -- Giving similar node ids for each layer (from 0 to ncpl) 
				.assign(inpl=np.tile(np.arange(self.mm.ncpl), self.mm.nlay))
				# -- Take only active cells
				.query('active == 1 & inest == 0')
				# -- Group by i-nodes
				.groupby('inpl')
				# -- Take the vertices of the cell (first layer)
				.first()['vertices']
				# -- Convert into polygons
				.map(Polygon)
			)
		)
		# -- Plot active domain + borders
		ax.plot(*uu.exterior.coords.xy, 
			    lw=1.5, color='k', zorder=30)
		ax.fill(*uu.exterior.coords.xy,
				color='lightgrey', alpha=.6,
				zorder=10, label='Active domain')
		# -- Plot cross line 
		ax.plot(*self.xsline.coords.xy,
			    label ='Cross-section line', **kwargs)
		# -- Add grid xy-lines
		ax.grid(color='lightgrey', lw=.4, zorder=5)
		# -- Add legend
		ax.legend()
		# -- Return axis
		return ax



	def plot_xs(self, vertical_ratio=None, extent=None, by_layer=False, **kwargs):
		"""
		Visualize crossed cells in xz-dimension.

		Parameters:
		-----------
		vertical_ratio (int/float, optional): ratio between x- and z- dimension.
		                            Default is None (equivalent to 'auto' aspect).
		extent (tuple/list, optional): xy-limits of the plot window.
                                       Format: (xmin, ymin, xmax, ymax).
                                       If None, window correspond to the
                                       entire model domain.
                                       Default is None.
        by_layer (bool, optional): whatever inserting a different facecolor for each layer.
        						   Note: this will add a explained colorbar referencing
        						         the layer id on top of the figure.
        						   Default is False.
   		**kwargs: matplotlib.PathCollection arguments.
                  (ex: cmap, lw, ls, edgecolor, ...)

        Returns:
        ----------
        ax (Axesubplot) : output matplotlib subplot.

        Examples:
        --------
        ax = xs.plot_xs(by_layer=True, ec='white', lw=.3)
        plt.show()
		"""
		# -- Extract patches
		patches = self.xs_df['zvertices'].apply(Path)

		# -- Build a collection from rectangles patches
		collection = PathCollection(patches)

		if by_layer:
			# -- Set layer ids as array
			collection.set_array(self.xs_df['layer'].values)

			# -- Set cmap
			cm = kwargs.pop('cmap', 'tab20')
			cmap = plt.cm.get_cmap(cm, self.mm.nlay)
			collection.set_cmap(cmap)

		# ---- Prepare basic axe if not provided
		plt.rc('font', family='serif', size=10)
		fig, ax = plt.subplots(figsize=(14, 6))

		# ---- Set plot extension
		if extent is not None:
			ax.set_xlim(*extent[::2])
			ax.set_ylim(*extent[1::2])
		else:
			# -- Extract xz-limits
			xmin = np.min(self.xs_df[['x_curv0', 'x_curv1']].values)
			xmax = np.max(self.xs_df[['x_curv0', 'x_curv1']].values)
			zmin = np.min(self.xs_df[['top', 'bottom']].values)
			zmax = np.max(self.xs_df[['top', 'bottom']].values)
			# -- Set xz-limits 
			ax.set_xlim(xmin, xmax)
			ax.set_ylim(zmin, zmax)

		# -- Hide top axis
		ax.spines['top'].set_visible(False)

		# -- Add collection default then user kwargs
		collection.set(**DEFAULT_PATH_KWARGS)
		collection.set(**kwargs)

		# ---- Add collection object to main axe
		ax.add_collection(collection)

		# -- Set color to each distinct layer
		if by_layer:
			# -- Build horizontal discrete colorbar
			bounds = np.arange(0, self.mm.nlay)
			cb = plt.colorbar(
			    ax=ax,
			    mappable=ax.collections[0],
			    boundaries=bounds,
			    **DEFAULT_LAYERS_COLORBAR_KWARGS
			)

			# -- Remove colorbar ticks 
			cb.ax.tick_params(axis='x',  size=0)

			# -- Write layer ids inside colorbar
			for i, v in enumerate(bounds):
			    cb.ax.text(x=i + 0.5, y=.4, s=str(int(v)), ha='center', va='center')

			# -- Set colorbar outline properties 
			cb.outline.set(**{'lw': .7, 'color': 'k'})

			# -- Add title to colorbar
			cb.ax.set_title('LAYERS', loc='center')

			# -- Add an id to axesubplot
			ax.set_gid('xs_layer')

		else:
			# -- Add an id to axesubplot
			ax.set_gid('xs')

		# -- Set vertical ratio if required
		if vertical_ratio is not None:
			ax.set_aspect(vertical_ratio)

		# ---- Return axe
		return ax




	def plot_xs_field(self, field='permh',
							log=False,
							vmin=None,
							vmax=None,
							cmap='viridis', 
							vertical_ratio=None,
							extent=None,
							cb_kwargs={},
							**kwargs):
		"""
		Visualize crossed cells in xz-dimension filled by given field values.

		Parameters:
		-----------
		field (str/MartheField, optional): field to consider.
		                                   Default is 'permh'.
		log (bool, optional) : whatever perform logaritmic transformation on field values.
                               Default is False.
        vmin, vmax (float, optional) : min/max field value(s) to plot.
        cmap (str, optional): matplotlib colormap name.
                              Default is 'viridis'.
		vertical_ratio (int/float, optional): ratio between x- and z- dimension.
		                            Default is None (equivalent to 'auto' aspect).
		extent (tuple/list, optional): xy-limits of the plot window.
                                       Format: (xmin, ymin, xmax, ymax).
                                       If None, window correspond to the
                                       entire model domain.
                                       Default is None.
        cb_kwargs (dict, optional): colorbar arguments to customized generated colorbar.
                          			(ex: {'shrink': .75, 'location': 'bottom'})
                          			Default is {}.
   		**kwargs: matplotlib.PathCollection arguments.
                  (ex: lw, ls, edgecolor, ...)

        Returns:
        ----------
        ax (Axesubplot) : output matplotlib subplot.

        Examples:
        --------
        ax = xs.plot_xs(by_layer=True, ec='white', lw=.3)
        plt.show()

		"""

		# -- Manage field input and extract data from it
		if isinstance(field, str):
			if not field in self.mm.prop.keys():
				self.mm.load_prop(field)
			rec = self.mm.prop[field].get_data()
			field_name = field
		elif isinstance(field, MartheField):
			rec = field.get_data()
			field_name = field.field
		else:
			msg = '`field` argument must be either a `str` of a valid property field' \
				  f' or a `MartheField` instance. Given {type(field)}.'
			raise TypeError(msg)

		# -- Extract patches
		patches = self.xs_df['zvertices'].apply(Path)

		# -- Build a collection from rectangles patches
		collection = PathCollection(patches)

		# ---- Prepare basic axe if not provided
		plt.rc('font', family='serif', size=10)
		fig, ax = plt.subplots(figsize=(14, 6))

		# ---- Set plot extension
		if extent is not None:
			ax.set_xlim(*extent[::2])
			ax.set_ylim(*extent[1::2])
		else:
			# -- Extract xz-limits
			xmin = np.min(self.xs_df[['x_curv0', 'x_curv1']].values)
			xmax = np.max(self.xs_df[['x_curv0', 'x_curv1']].values)
			zmin = np.min(self.xs_df[['top', 'bottom']].values)
			zmax = np.max(self.xs_df[['top', 'bottom']].values)
			# -- Set xz-limits 
			ax.set_xlim(xmin, xmax)
			ax.set_ylim(zmin, zmax)

		# -- Hide top axis
		ax.spines['top'].set_visible(False)

		# -- Add collection default then user kwargs
		collection.set(**DEFAULT_PATH_KWARGS)
		collection.set(**kwargs)

		# -- Extract data on cross section cells and apply log-transformation if required
		if log:
			arr = np.log10(rec['value'][self.valid_xsnodes])
		else:
			arr = rec['value'][self.valid_xsnodes]

		# -- Set values of each intersected cell
		collection.set_array(arr)

		# -- Set colormap to collections
		collection.set_cmap(cmap)

		# ---- Add collection object to main axe
		ax.add_collection(collection)

		# -- Set default values limites
		vmin = arr.min() if vmin is None else vmin
		vmax = arr.max() if vmax is None else vmax
		collection.set_clim(vmin=vmin, vmax=vmax)

		# -- Build a normalized scalar mappable object
		norm = plt.Normalize(vmin, vmax)
		sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)

		# -- Build colorbar with/without default parameters
		label = f'log({field_name})' if log else field_name
		cb_kwargs = cb_kwargs if len(cb_kwargs) > 0 else DEFAULT_ARRAY_COLORBAR_KWARGS
		cb = plt.colorbar(sm, ax=ax, label=label, **cb_kwargs)

		# -- Add an id to optional colorbar
		ax.set_gid('xs_field')

		# -- Set vertical ratio if required
		if vertical_ratio is not None:
			ax.set_aspect(vertical_ratio)

		# ---- Return axe
		return cb, ax


	def add_location(self, ax, loc, tolerance=None, text_kws=None, **kwargs):
		"""
		Adding a vertical line to a cross section plot from xy-coordinates.

		Parameters:
		-----------
		ax (AxeSubplot): existing axe generated by `.plot_xs()`
						 or `.plot_xs_field()` methods.
		loc (shapely.geometry.Point/iterable): points xy-coordinates.
		tolerance (float/int/None, optional): distance around the cross line to accept or
									          denied plotting the vertical line on plot
		text_kws (dict, None, optional): optional `plt.text()` arguments to write in plot.
		                                 If None, text will not be added.
		                                 Default is None.
		**kwargs: matplotlib.AxeSubplot.axvline arguments
		          (ex: lw, ls, color, ...)
		
        Examples:
        --------
		ax = xs.plot_xs(by_layer=True)
		trans = blended_transform_factory(ax.transData, ax.transAxes)
		xs.add_location(ax, loc=(355, 291),
			tolerance=None,
			text_kws=dict(y=1.03, s='Bordeaux',
				color='red', transform=trans,
				va='center', ha='center'),
			lw=.8, color='red')
		plt.show()
		"""
		# -- Validate input ax
		self.validate_ax(ax)
		# -- Extract axis x-limit
		xmin, xmax = ax.get_xlim()
		# -- Get location as shapely Point
		point = loc if isinstance(loc, Point) else Point(loc)
		# -- Assure isn't to far from the cross section line
		is_near = True if tolerance is None else point.within(self.xsline.buffer(tolerance))
		# Extract curvilinear abscissa
		xcurv = self.xsline.project(point)
		# -- Check if point can be plot
		if (is_near) & (xmin < xcurv < xmax):
			# Plot vertical line on giving location
			ax.axvline(x=xcurv, **kwargs)
			# Write additionnal text if required
			if text_kws is not None:
				x = text_kws.pop('x', xcurv)
				y = text_kws.pop('y', 0)
				s = text_kws.pop('s', 'loc')
				ax.text(x=x, y=y, s=s, **text_kws)



	def add_vertices_locations(self, ax, text_kws={}, prefix='', **kwargs):
		"""
		Adding a vertical line to a cross section plot at cross line vertices (if exists).

		Parameters:
		-----------
		ax (AxeSubplot): existing axe generated by `.plot_xs()`
						 or `.plot_xs_field()` methods.
		text_kws (dict, optional): optional `plt.text()` arguments to write in plot.
		                           If None, text will not be added.
		                           Default is {}.
		prefix (str, optional): input prefix before vertices number.
		                        Default is ''.
		**kwargs: matplotlib.AxeSubplot.axvline arguments
		          (ex: lw, ls, color, ...)
		
        Examples:
        --------
        ax = xs.plot_xs(by_layer=True)
		xs.add_vertices_locations(
			ax,
			text_kws={'color': 'red'},
			color='red'
			)
		"""
		# -- Validate input ax
		self.validate_ax(ax)
		# -- Manage text kwargs
		if text_kws is None:
			text_kws = dict()
		else:
			# -- Remove 'x' and 's' key if exist
			x = text_kws.pop('x', None)
			# -- Manage custom y-transformation
			if not 'y' in text_kws.keys():
				text_kws.update(
					{
					'y': 1.03,
					'transform': blended_transform_factory(
						ax.transData,
						ax.transAxes
						),
					'ha': 'center',
					'va': 'center'
					}
				)
		# -- Iterate over all cross line vertices adding vertical line
		for i, point in enumerate(self.xsline.coords):
			# -- Update vertice text
			s = text_kws.get('s', prefix + str(i))
			# -- Add location with text
			self.add_location(
				ax=ax,
				loc=point,
				text_kws= {**{'s': s}, **text_kws},
				**kwargs
				)

